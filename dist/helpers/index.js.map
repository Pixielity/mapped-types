{"version":3,"sources":["../../src/logger.ts","../../src/utils/logger.utils.ts","../../src/utils/apply-is-optional-decorator.utils.ts","../../src/utils/inherit-validation-metadata.utils.ts","../../src/utils/inherit-property-initializers.utils.ts","../../src/utils/inherit-transformation-metadata.utils.ts","../../src/utils/apply-validate-if-defined-decorator.utils.ts","../../src/helpers/intersection-type.helper.ts","../../src/helpers/omit-type.helper.ts","../../src/helpers/partial-type.helper.ts","../../src/helpers/pick-type.helper.ts"],"names":["isClassValidatorAvailable","key"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * @class Logger\n * @description A simple logger class for logging messages with different log levels.\n * This class provides methods for logging messages with different severity levels\n * and includes the context (module name) in the log output.\n */\nexport class Logger {\n  /**\n   * Creates a new Logger instance with the specified context.\n   * @param context The context (usually module name) to include in log messages\n   */\n  constructor(private readonly context: string) {}\n\n  /**\n   * Logs an error message.\n   * @param message The message to log\n   * @param trace Optional stack trace or error object\n   */\n  error(message: any, trace?: string | Error): void {\n    const timestamp = new Date().toISOString()\n    const formattedMessage = `[${timestamp}] [ERROR] [${this.context}] ${message}`\n\n    console.error(formattedMessage)\n\n    if (trace) {\n      if (trace instanceof Error) {\n        console.error(trace.stack)\n      } else {\n        console.error(trace)\n      }\n    }\n  }\n\n  /**\n   * Logs a warning message.\n   * @param message The message to log\n   */\n  warn(message: any): void {\n    const timestamp = new Date().toISOString()\n    console.warn(`[${timestamp}] [WARN] [${this.context}] ${message}`)\n  }\n\n  /**\n   * Logs an informational message.\n   * @param message The message to log\n   */\n  info(message: any): void {\n    const timestamp = new Date().toISOString()\n    console.info(`[${timestamp}] [INFO] [${this.context}] ${message}`)\n  }\n\n  /**\n   * Logs a debug message.\n   * @param message The message to log\n   */\n  debug(message: any): void {\n    const timestamp = new Date().toISOString()\n    console.debug(`[${timestamp}] [DEBUG] [${this.context}] ${message}`)\n  }\n\n  /**\n   * Logs a verbose message.\n   * @param message The message to log\n   */\n  verbose(message: any): void {\n    const timestamp = new Date().toISOString()\n    console.log(`[${timestamp}] [VERBOSE] [${this.context}] ${message}`)\n  }\n}\n","import { Logger } from '../logger'\n\n/**\n * @description Centralized logger instance for the MappedTypes module.\n * Used to log errors and other information during the execution of the module.\n * This logger provides consistent formatting and context for all log messages.\n *\n * @example\n * ```typescript\n * // Log an error message\n * logger.error('An error occurred while processing metadata');\n *\n * // Log an error with a stack trace\n * try {\n *   // Some code that might throw\n * } catch (err) {\n *   logger.error('Failed to process metadata', err);\n * }\n * ```\n */\nexport const logger = new Logger('MappedTypes')\n","/**\n * @function applyIsOptionalDecorator\n * @description Applies the IsOptional decorator from class-validator to a property of a class.\n * This makes the property optional for validation purposes, allowing null or undefined values.\n * If class-validator is not available, this function does nothing.\n *\n * @param targetClass - The class constructor to apply the decorator to\n * @param propertyKey - The name of the property to make optional\n *\n * @example\n * ```typescript\n * class UserDto {\n *   @IsString()\n *   name: string;\n * }\n *\n * // Make the name property optional\n * applyIsOptionalDecorator(UserDto, 'name');\n * ```\n */\nexport function applyIsOptionalDecorator(targetClass: Function, propertyKey: string) {\n  // Check if class-validator is available in the project\n  if (!isClassValidatorAvailable()) {\n    return\n  }\n\n  // Import class-validator dynamically\n  const classValidator: typeof import('class-validator') = require('class-validator')\n\n  // Create the IsOptional decorator factory\n  const decoratorFactory = classValidator.IsOptional()\n\n  // Apply the decorator to the target class property\n  decoratorFactory(targetClass.prototype, propertyKey)\n}\n\n/**\n * @function isClassValidatorAvailable\n * @description Checks if the class-validator package is available in the project.\n * This is used to gracefully handle cases where class-validator is not installed.\n *\n * @returns {boolean} True if class-validator is available, false otherwise\n *\n * @internal\n */\nfunction isClassValidatorAvailable() {\n  try {\n    // Attempt to require class-validator\n    require('class-validator')\n    return true\n  } catch {\n    // Return false if class-validator is not available\n    return false\n  }\n}\n","import 'reflect-metadata'\n\nimport type { Type } from '../types'\nimport { logger } from './logger.utils'\n\n/**\n * @function inheritValidationMetadata\n * @description Inherits validation metadata from a parent class to a target class.\n * This allows the target class to have the same validation rules as the parent class.\n * If class-validator is not available, this function does nothing.\n *\n * @param parentClass - The class to inherit validation metadata from\n * @param targetClass - The class to apply the inherited validation metadata to\n * @param isPropertyInherited - Optional function to determine if a property should be inherited\n *\n * @returns {string[] | undefined} An array of property names that had validation metadata applied,\n *                                or undefined if class-validator is not available or an error occurred\n *\n * @example\n * ```typescript\n * class UserDto {\n *   @IsString()\n *   name: string;\n * }\n *\n * class CreateUserDto {\n *   // This class will inherit the validation metadata for the name property\n * }\n *\n * inheritValidationMetadata(UserDto, CreateUserDto);\n * ```\n */\nexport function inheritValidationMetadata(\n  parentClass: Type<any>,\n  targetClass: Function,\n  isPropertyInherited?: (key: string) => boolean,\n) {\n  // Check if class-validator is available in the project\n  if (!isClassValidatorAvailable()) {\n    return\n  }\n\n  try {\n    // Import class-validator dynamically\n    const classValidator: typeof import('class-validator') = require('class-validator')\n\n    // Get the metadata storage from class-validator\n    // This handles different versions of class-validator\n    const metadataStorage: import('class-validator').MetadataStorage = (classValidator as any)\n      .getMetadataStorage\n      ? (classValidator as any).getMetadataStorage()\n      : classValidator.getFromContainer(classValidator.MetadataStorage)\n\n    // Arguments for getting target validation metadata\n    const getTargetValidationMetadatasArgs = [parentClass, null!, false, false]\n\n    // Get the validation metadata from the parent class\n    const targetMetadata: ReturnType<typeof metadataStorage.getTargetValidationMetadatas> = (\n      metadataStorage.getTargetValidationMetadatas as Function\n    )(...getTargetValidationMetadatasArgs)\n\n    // Filter and map the metadata to apply to the target class\n    return (\n      targetMetadata\n        // Only include properties that should be inherited\n        .filter(({ propertyName }) => !isPropertyInherited || isPropertyInherited(propertyName))\n        .map((value) => {\n          // Get the original type metadata\n          const originalType = Reflect.getMetadata(\n            'design:type',\n            parentClass.prototype,\n            value.propertyName,\n          )\n\n          // If the original type exists, define it on the target class\n          if (originalType) {\n            Reflect.defineMetadata(\n              'design:type',\n              originalType,\n              targetClass.prototype,\n              value.propertyName,\n            )\n          }\n\n          // Add the validation metadata to the target class\n          metadataStorage.addValidationMetadata({\n            ...value,\n            target: targetClass,\n          })\n\n          // Return the property name that was processed\n          return value.propertyName\n        })\n    )\n  } catch (err: Error | any) {\n    // Log errors that occur during the inheritance process\n    logger.error(\n      `Validation (\"class-validator\") metadata cannot be inherited for \"${parentClass.name}\" class.`,\n    )\n    logger.error(err)\n  }\n}\n\n/**\n * @function isClassValidatorAvailable\n * @description Checks if the class-validator package is available in the project.\n * This is used to gracefully handle cases where class-validator is not installed.\n *\n * @returns {boolean} True if class-validator is available, false otherwise\n *\n * @internal\n */\nfunction isClassValidatorAvailable() {\n  try {\n    // Attempt to require class-validator\n    require('class-validator')\n    return true\n  } catch {\n    // Return false if class-validator is not available\n    return false\n  }\n}\n","import type { Type } from '../types'\n\n/**\n * @function inheritPropertyInitializers\n * @description Inherits property initializers from a source class to a target object.\n * This copies the default values of properties from an instance of the source class\n * to the target object, but only for properties that are undefined in the target.\n *\n * @param target - The target object to inherit property initializers to\n * @param sourceClass - The source class to inherit property initializers from\n * @param isPropertyInherited - Optional function to determine if a property should be inherited\n *                             (defaults to inheriting all properties)\n *\n * @example\n * ```typescript\n * class UserDto {\n *   name: string = 'Default Name';\n *   isActive: boolean = true;\n * }\n *\n * const target = {};\n * inheritPropertyInitializers(target, UserDto);\n * // target is now { name: 'Default Name', isActive: true }\n * ```\n */\nexport function inheritPropertyInitializers(\n  target: Record<string, any>,\n  sourceClass: Type<any>,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  isPropertyInherited = (key: string) => true,\n) {\n  try {\n    // Create a temporary instance of the source class to get its property values\n    const tempInstance = new sourceClass()\n\n    // Get all property names from the temporary instance\n    const propertyNames = Object.getOwnPropertyNames(tempInstance)\n\n    // Filter and copy properties\n    propertyNames\n      // Only include properties that are defined in the source and undefined in the target\n      .filter(\n        (propertyName) =>\n          typeof tempInstance[propertyName] !== 'undefined' &&\n          typeof target[propertyName] === 'undefined',\n      )\n      // Only include properties that should be inherited according to the predicate\n      .filter((propertyName) => isPropertyInherited(propertyName))\n      // Copy each property from the source to the target\n      .forEach((propertyName) => {\n        target[propertyName] = tempInstance[propertyName]\n      })\n  } catch {\n    // Ignore errors that might occur during instantiation or property copying\n    // This allows the function to fail gracefully if the source class can't be instantiated\n  }\n}\n","import { logger } from './logger.utils'\nimport type { Type, TransformMetadataKey } from '../types'\n\n/**\n * @function inheritTransformationMetadata\n * @description Inherits transformation metadata from a parent class to a target class.\n * This allows the target class to have the same transformation rules as the parent class.\n * If class-transformer is not available, this function does nothing.\n *\n * @param parentClass - The class to inherit transformation metadata from\n * @param targetClass - The class to apply the inherited transformation metadata to\n * @param isPropertyInherited - Optional function to determine if a property should be inherited\n * @param stackDecorators - Whether to stack decorators or replace them (default: true)\n *\n * @example\n * ```typescript\n * class UserDto {\n *   @Expose()\n *   name: string;\n *\n *   @Exclude()\n *   password: string;\n * }\n *\n * class CreateUserDto {\n *   // This class will inherit the transformation metadata for the name and password properties\n * }\n *\n * inheritTransformationMetadata(UserDto, CreateUserDto);\n * ```\n */\nexport function inheritTransformationMetadata(\n  parentClass: Type<any>,\n  targetClass: Function,\n  isPropertyInherited?: (key: string) => boolean,\n  stackDecorators = true,\n) {\n  // Check if class-transformer is available in the project\n  if (!isClassTransformerAvailable()) {\n    return\n  }\n\n  try {\n    // Define the metadata keys to inherit\n    const transformMetadataKeys: TransformMetadataKey[] = [\n      '_typeMetadatas',\n      '_exposeMetadatas',\n      '_excludeMetadatas',\n      '_transformMetadatas',\n    ]\n\n    // Inherit each type of metadata\n    transformMetadataKeys.forEach((key) =>\n      inheritTransformerMetadata(\n        key,\n        parentClass,\n        targetClass,\n        isPropertyInherited,\n        stackDecorators,\n      ),\n    )\n  } catch (err: Error | any) {\n    // Log errors that occur during the inheritance process\n    logger.error(\n      `Transformer (\"class-transformer\") metadata cannot be inherited for \"${parentClass.name}\" class.`,\n    )\n    logger.error(err)\n  }\n}\n\n/**\n * @function inheritTransformerMetadata\n * @description Helper function that inherits a specific type of transformation metadata\n * from a parent class to a target class.\n *\n * @param key - The metadata key to inherit\n * @param parentClass - The class to inherit metadata from\n * @param targetClass - The class to apply the inherited metadata to\n * @param isPropertyInherited - Optional function to determine if a property should be inherited\n * @param stackDecorators - Whether to stack decorators or replace them\n *\n * @internal\n */\nfunction inheritTransformerMetadata(\n  key: TransformMetadataKey,\n  parentClass: Type<any>,\n  targetClass: Function,\n  isPropertyInherited?: (key: string) => boolean,\n  stackDecorators = true,\n) {\n  let classTransformer: any\n\n  try {\n    // Try to import class-transformer from the cjs path (for newer versions)\n    /** \"class-transformer\" >= v0.3.x */\n    classTransformer = require('class-transformer/cjs/storage')\n  } catch {\n    // Fall back to the older import path\n    /** \"class-transformer\" <= v0.3.x */\n    classTransformer = require('class-transformer/storage')\n  }\n\n  // Get the metadata storage from class-transformer\n  const metadataStorage /*: typeof import('class-transformer/types/storage').defaultMetadataStorage */ =\n    classTransformer.defaultMetadataStorage\n\n  // Traverse the prototype chain to inherit metadata from all parent classes\n  while (parentClass && parentClass !== Object) {\n    // Check if the parent class has metadata for the current key\n    if (metadataStorage[key].has(parentClass)) {\n      // Get the metadata map for the current key\n      const metadataMap = metadataStorage[key] as Map<Function, Map<string, any>>\n      // Get the parent metadata\n      const parentMetadata = metadataMap.get(parentClass)\n\n      // Create target metadata entries by filtering and mapping parent metadata\n      const targetMetadataEntries: Iterable<[string, any]> = Array.from(parentMetadata!.entries())\n        // Only include properties that should be inherited\n        .filter(([key]) => !isPropertyInherited || isPropertyInherited(key))\n        // Map each entry to update the target reference\n        .map(([key, metadata]) => {\n          if (Array.isArray(metadata)) {\n            // \"_transformMetadatas\" is an array of elements\n            // Create a new array with updated target references\n            const targetMetadata = metadata.map((item) => ({\n              ...item,\n              target: targetClass,\n            }))\n            return [key, targetMetadata]\n          }\n          // For non-array metadata, just update the target reference\n          return [key, { ...metadata, target: targetClass }]\n        })\n\n      // If the target class already has metadata for this key\n      if (metadataMap.has(targetClass)) {\n        // Get the existing rules\n        const existingRules = metadataMap.get(targetClass)!.entries()\n        // Create a new map to merge the existing and new metadata\n        const mergeMap = new Map<string, any[]>()\n\n        // Merge the existing and new metadata\n        ;[existingRules, targetMetadataEntries].forEach((entries) => {\n          for (const [valueKey, value] of entries) {\n            if (mergeMap.has(valueKey) && stackDecorators) {\n              // If the key already exists and we're stacking decorators\n              const parentValue = mergeMap.get(valueKey)\n\n              if (Array.isArray(parentValue)) {\n                // Merge parent and child arrays if the parent value is an array\n                parentValue.push(...(Array.isArray(value) ? value : [value]))\n              }\n            } else {\n              // Otherwise, just set the value\n              mergeMap.set(valueKey, value)\n            }\n          }\n        })\n\n        // Update the metadata map with the merged map\n        metadataMap.set(targetClass, mergeMap)\n      } else {\n        // If the target class doesn't have metadata for this key yet,\n        // create a new map with the target metadata entries\n        metadataMap.set(targetClass, new Map(targetMetadataEntries))\n      }\n    }\n\n    // Move up the prototype chain\n    parentClass = Object.getPrototypeOf(parentClass)\n  }\n}\n\n/**\n * @function isClassTransformerAvailable\n * @description Checks if the class-transformer package is available in the project.\n * This is used to gracefully handle cases where class-transformer is not installed.\n *\n * @returns {boolean} True if class-transformer is available, false otherwise\n *\n * @internal\n */\nfunction isClassTransformerAvailable() {\n  try {\n    // Attempt to require class-transformer\n    require('class-transformer')\n    return true\n  } catch {\n    // Return false if class-transformer is not available\n    return false\n  }\n}\n","/**\n * @function applyValidateIfDefinedDecorator\n * @description Applies the ValidateIf decorator from class-validator to a property of a class.\n * This makes the validation only run if the property is defined (not undefined).\n * If class-validator is not available, this function does nothing.\n *\n * @param targetClass - The class constructor to apply the decorator to\n * @param propertyKey - The name of the property to conditionally validate\n *\n * @example\n * ```typescript\n * class UserDto {\n *   @IsString()\n *   name: string;\n * }\n *\n * // Only validate the name property if it's defined\n * applyValidateIfDefinedDecorator(UserDto, 'name');\n * ```\n */\nexport function applyValidateIfDefinedDecorator(targetClass: Function, propertyKey: string) {\n  // Check if class-validator is available in the project\n  if (!isClassValidatorAvailable()) {\n    return\n  }\n\n  // Import class-validator dynamically\n  const classValidator: typeof import('class-validator') = require('class-validator')\n\n  // Create the ValidateIf decorator factory that only validates if the value is not undefined\n  const decoratorFactory = classValidator.ValidateIf((_, value) => value !== undefined)\n\n  // Apply the decorator to the target class property\n  decoratorFactory(targetClass.prototype, propertyKey)\n}\n\n/**\n * @function isClassValidatorAvailable\n * @description Checks if the class-validator package is available in the project.\n * This is used to gracefully handle cases where class-validator is not installed.\n *\n * @returns {boolean} True if class-validator is available, false otherwise\n *\n * @internal\n */\nfunction isClassValidatorAvailable() {\n  try {\n    // Attempt to require class-validator\n    require('class-validator')\n    return true\n  } catch {\n    // Return false if class-validator is not available\n    return false\n  }\n}\n","import {\n  inheritValidationMetadata,\n  inheritPropertyInitializers,\n  inheritTransformationMetadata,\n} from '../utils'\nimport type { MappedType } from '../interfaces'\nimport type { Type, RemoveFieldsWithType } from '../types'\n\n/**\n * @type UnionToIntersection\n * @description Utility type that converts a union type to an intersection type.\n * This uses a clever trick with function parameters and return types to achieve the conversion.\n *\n * @template U The union type to convert to an intersection\n *\n * @example\n * ```typescript\n * type Union = { a: string } | { b: number };\n * // Becomes { a: string } & { b: number }\n * type Intersection = UnionToIntersection<Union>;\n * ```\n *\n * @see https://stackoverflow.com/questions/50374908/transform-union-type-to-intersection-type\n */\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void\n  ? I\n  : never\n\n/**\n * @type ClassRefsToConstructors\n * @description Utility type that converts an array of class references to an array of their instance types.\n * It uses the infer keyword to extract the instance type from each Type<T>.\n *\n * @template T The array of class references to convert\n *\n * @example\n * ```typescript\n * type ClassRefs = [Type<Foo>, Type<Bar>];\n * // Becomes [Foo, Bar]\n * type Constructors = ClassRefsToConstructors<ClassRefs>;\n * ```\n */\ntype ClassRefsToConstructors<T extends Type[]> = {\n  [U in keyof T]: T[U] extends Type<infer V> ? V : never\n}\n\n/**\n * @type Intersection\n * @description Utility type that creates an intersection type from an array of class references.\n * It first converts the array of class references to an array of their instance types,\n * then converts that array to a union type using indexed access,\n * and finally converts the union type to an intersection type.\n *\n * @template T The array of class references to create an intersection from\n *\n * @example\n * ```typescript\n * class Foo { a: string; }\n * class Bar { b: number; }\n *\n * // Becomes MappedType<Foo & Bar>\n * type FooBar = Intersection<[Type<Foo>, Type<Bar>]>;\n * ```\n */\ntype Intersection<T extends Type[]> = MappedType<\n  RemoveFieldsWithType<UnionToIntersection<ClassRefsToConstructors<T>[number]>, Function>\n>\n\n/**\n * @function IntersectionType\n * @description Creates a new type by intersecting multiple existing classes.\n * The resulting type will have all properties from all the input classes.\n * It also inherits validation and transformation metadata from all input classes.\n *\n * @param classRefs - The classes to intersect\n *\n * @returns A new class with all properties from all input classes\n *\n * @example\n * ```typescript\n * class UserDto {\n *   @IsString()\n *   name: string;\n * }\n *\n * class AddressDto {\n *   @IsString()\n *   street: string;\n * }\n *\n * // UserWithAddressDto will have both name and street properties\n * // with the same validation rules as the original classes\n * class UserWithAddressDto extends IntersectionType(UserDto, AddressDto) {}\n * ```\n *\n * @publicApi\n */\nexport function IntersectionType<T extends Type[]>(...classRefs: T) {\n  /**\n   * Abstract class that will be returned as the intersection type\n   * It inherits property initializers from all source classes\n   */\n  abstract class IntersectionClassType {\n    constructor() {\n      // Inherit property initializers from all source classes\n      classRefs.forEach((classRef) => {\n        inheritPropertyInitializers(this, classRef)\n      })\n    }\n  }\n\n  // Inherit validation and transformation metadata from all source classes\n  classRefs.forEach((classRef) => {\n    inheritValidationMetadata(classRef, IntersectionClassType)\n    inheritTransformationMetadata(classRef, IntersectionClassType, undefined, false)\n  })\n\n  // Set the name of the class to reflect that it's an intersection of the source classes\n  const intersectedNames = classRefs.reduce((prev, ref) => prev + ref.name, '')\n  Object.defineProperty(IntersectionClassType, 'name', {\n    value: `Intersection${intersectedNames}`,\n  })\n\n  // Return the class as a MappedType\n  return IntersectionClassType as Intersection<T>\n}\n","import {\n  inheritValidationMetadata,\n  inheritPropertyInitializers,\n  inheritTransformationMetadata,\n} from '../utils'\nimport type { MappedType } from '../interfaces'\nimport type { Type, RemoveFieldsWithType } from '../types'\n\n/**\n * @function OmitType\n * @description Creates a new type by omitting a set of properties from an existing class.\n * The resulting type will have all properties except those specified in the keys array.\n * It also inherits validation and transformation metadata for the remaining properties.\n *\n * @param classRef - The class to omit properties from\n * @param keys - An array of property names to omit\n *\n * @returns A new class without the omitted properties\n *\n * @example\n * ```typescript\n * class UserDto {\n *   @IsString()\n *   name: string;\n *\n *   @IsEmail()\n *   email: string;\n *\n *   @IsString()\n *   password: string;\n * }\n *\n * // UserResponseDto will have name and email properties, but not password\n * // with the same validation rules as UserDto\n * class UserResponseDto extends OmitType(UserDto, ['password']) {}\n * ```\n *\n * @publicApi\n */\nexport function OmitType<T, K extends keyof T>(classRef: Type<T>, keys: readonly K[]) {\n  // Create a predicate function to determine if a property should be inherited\n  const isInheritedPredicate = (propertyKey: string) => !keys.includes(propertyKey as K)\n\n  /**\n   * Abstract class that will be returned as the omitted type\n   * It inherits property initializers from the source class\n   */\n  abstract class OmitClassType {\n    constructor() {\n      // Inherit property initializers from the source class\n      inheritPropertyInitializers(this, classRef, isInheritedPredicate)\n    }\n  }\n\n  // Inherit validation metadata from the source class\n  inheritValidationMetadata(classRef, OmitClassType, isInheritedPredicate)\n  // Inherit transformation metadata from the source class\n  inheritTransformationMetadata(classRef, OmitClassType, isInheritedPredicate)\n\n  // Return the class as a MappedType\n  // The type is an Omit of the original type, with Function fields removed\n  return OmitClassType as MappedType<RemoveFieldsWithType<Omit<T, (typeof keys)[number]>, Function>>\n}\n","import {\n  applyIsOptionalDecorator,\n  inheritValidationMetadata,\n  inheritPropertyInitializers,\n  inheritTransformationMetadata,\n  applyValidateIfDefinedDecorator,\n} from '../utils'\nimport type { MappedType } from '../interfaces'\nimport type { Type, RemoveFieldsWithType } from '../types'\n\n/**\n * @function PartialType\n * @description Creates a new type by making all properties of an existing class optional.\n * The resulting type will have the same properties as the input class, but all will be optional.\n * It also inherits validation and transformation metadata, and applies IsOptional or ValidateIf\n * decorators to make validation rules respect the optional nature of the properties.\n *\n * @param classRef - The class to make properties optional for\n * @param options - Configuration options\n * @param options.skipNullProperties - If true, validations will be ignored for null or undefined values.\n *                                    If false, validations will be ignored only for undefined values.\n *                                    Defaults to true.\n *\n * @returns A new class with all properties made optional\n *\n * @example\n * ```typescript\n * class UserDto {\n *   @IsString()\n *   name: string;\n *\n *   @IsEmail()\n *   email: string;\n * }\n *\n * // UpdateUserDto will have optional name and email properties\n * // with the same validation rules as UserDto, but they'll only be\n * // applied if the properties are defined\n * class UpdateUserDto extends PartialType(UserDto) {}\n * ```\n *\n * @publicApi\n */\nexport function PartialType<T>(\n  classRef: Type<T>,\n  /**\n   *  Configuration options.\n   */\n  options: {\n    /**\n     * If true, validations will be ignored on a property if it is either null or undefined. If\n     * false, validations will be ignored only if the property is undefined.\n     * @default true\n     */\n    skipNullProperties?: boolean\n  } = {},\n) {\n  /**\n   * Abstract class that will be returned as the partial type\n   * It inherits property initializers from the source class\n   */\n  abstract class PartialClassType {\n    constructor() {\n      // Inherit property initializers from the source class\n      inheritPropertyInitializers(this, classRef)\n    }\n  }\n\n  // Inherit validation and transformation metadata from the source class\n  const propertyKeys = inheritValidationMetadata(classRef, PartialClassType)\n  inheritTransformationMetadata(classRef, PartialClassType)\n\n  // Apply IsOptional or ValidateIf decorators to all properties with validation rules\n  if (propertyKeys) {\n    propertyKeys.forEach((key) => {\n      options.skipNullProperties === false\n        ? applyValidateIfDefinedDecorator(PartialClassType, key)\n        : applyIsOptionalDecorator(PartialClassType, key)\n    })\n  }\n\n  // Set the name of the class to reflect that it's a partial version of the source class\n  Object.defineProperty(PartialClassType, 'name', {\n    value: `Partial${classRef.name}`,\n  })\n\n  // Return the class as a MappedType\n  // The type is a Partial of the original type, with Function fields removed\n  return PartialClassType as MappedType<RemoveFieldsWithType<Partial<T>, Function>>\n}\n","import {\n  inheritValidationMetadata,\n  inheritPropertyInitializers,\n  inheritTransformationMetadata,\n} from '../utils'\nimport type { MappedType } from '../interfaces'\nimport type { Type, RemoveFieldsWithType } from '../types'\n\n/**\n * @function PickType\n * @description Creates a new type by picking a set of properties from an existing class.\n * The resulting type will have only the properties specified in the keys array.\n * It also inherits validation and transformation metadata for the picked properties.\n *\n * @param classRef - The class to pick properties from\n * @param keys - An array of property names to pick\n *\n * @returns A new class with only the picked properties\n *\n * @example\n * ```typescript\n * class UserDto {\n *   @IsString()\n *   name: string;\n *\n *   @IsEmail()\n *   email: string;\n *\n *   @IsString()\n *   password: string;\n * }\n *\n * // CreateUserDto will have name, email, and password properties\n * // with the same validation rules as UserDto\n * class CreateUserDto extends PickType(UserDto, ['name', 'email', 'password']) {}\n * ```\n *\n * @publicApi\n */\nexport function PickType<T, K extends keyof T>(classRef: Type<T>, keys: readonly K[]) {\n  // Create a predicate function to determine if a property should be inherited\n  const isInheritedPredicate = (propertyKey: string) => keys.includes(propertyKey as K)\n\n  /**\n   * Abstract class that will be returned as the picked type\n   * It inherits property initializers from the source class\n   */\n  abstract class PickClassType {\n    constructor() {\n      // Inherit property initializers from the source class\n      inheritPropertyInitializers(this, classRef, isInheritedPredicate)\n    }\n  }\n\n  // Inherit validation metadata from the source class\n  inheritValidationMetadata(classRef, PickClassType, isInheritedPredicate)\n  // Inherit transformation metadata from the source class\n  inheritTransformationMetadata(classRef, PickClassType, isInheritedPredicate)\n\n  // Return the class as a MappedType\n  // The type is a Pick of the original type, with Function fields removed\n  return PickClassType as MappedType<RemoveFieldsWithType<Pick<T, (typeof keys)[number]>, Function>>\n}\n"]}