{"version":3,"sources":["../../src/logger.ts","../../src/utils/logger.utils.ts","../../src/utils/inherit-validation-metadata.utils.ts","../../src/utils/inherit-property-initializers.utils.ts","../../src/utils/inherit-transformation-metadata.utils.ts","../../src/helpers/intersection-type.helper.ts"],"names":["key"],"mappings":"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","file":"intersection-type.helper.mjs","sourcesContent":["/**\n * @class Logger\n * @description A simple logger class for logging messages with different log levels.\n * This class provides methods for logging messages with different severity levels\n * and includes the context (module name) in the log output.\n */\nexport class Logger {\n  /**\n   * Creates a new Logger instance with the specified context.\n   * @param context The context (usually module name) to include in log messages\n   */\n  constructor(private readonly context: string) {}\n\n  /**\n   * Logs an error message.\n   * @param message The message to log\n   * @param trace Optional stack trace or error object\n   */\n  error(message: any, trace?: string | Error): void {\n    const timestamp = new Date().toISOString()\n    const formattedMessage = `[${timestamp}] [ERROR] [${this.context}] ${message}`\n\n    console.error(formattedMessage)\n\n    if (trace) {\n      if (trace instanceof Error) {\n        console.error(trace.stack)\n      } else {\n        console.error(trace)\n      }\n    }\n  }\n\n  /**\n   * Logs a warning message.\n   * @param message The message to log\n   */\n  warn(message: any): void {\n    const timestamp = new Date().toISOString()\n    console.warn(`[${timestamp}] [WARN] [${this.context}] ${message}`)\n  }\n\n  /**\n   * Logs an informational message.\n   * @param message The message to log\n   */\n  info(message: any): void {\n    const timestamp = new Date().toISOString()\n    console.info(`[${timestamp}] [INFO] [${this.context}] ${message}`)\n  }\n\n  /**\n   * Logs a debug message.\n   * @param message The message to log\n   */\n  debug(message: any): void {\n    const timestamp = new Date().toISOString()\n    console.debug(`[${timestamp}] [DEBUG] [${this.context}] ${message}`)\n  }\n\n  /**\n   * Logs a verbose message.\n   * @param message The message to log\n   */\n  verbose(message: any): void {\n    const timestamp = new Date().toISOString()\n    console.log(`[${timestamp}] [VERBOSE] [${this.context}] ${message}`)\n  }\n}\n","import { Logger } from '../logger'\n\n/**\n * @description Centralized logger instance for the MappedTypes module.\n * Used to log errors and other information during the execution of the module.\n * This logger provides consistent formatting and context for all log messages.\n *\n * @example\n * ```typescript\n * // Log an error message\n * logger.error('An error occurred while processing metadata');\n *\n * // Log an error with a stack trace\n * try {\n *   // Some code that might throw\n * } catch (err) {\n *   logger.error('Failed to process metadata', err);\n * }\n * ```\n */\nexport const logger = new Logger('MappedTypes')\n","import 'reflect-metadata'\n\nimport type { Type } from '../types'\nimport { logger } from './logger.utils'\n\n/**\n * @function inheritValidationMetadata\n * @description Inherits validation metadata from a parent class to a target class.\n * This allows the target class to have the same validation rules as the parent class.\n * If class-validator is not available, this function does nothing.\n *\n * @param parentClass - The class to inherit validation metadata from\n * @param targetClass - The class to apply the inherited validation metadata to\n * @param isPropertyInherited - Optional function to determine if a property should be inherited\n *\n * @returns {string[] | undefined} An array of property names that had validation metadata applied,\n *                                or undefined if class-validator is not available or an error occurred\n *\n * @example\n * ```typescript\n * class UserDto {\n *   @IsString()\n *   name: string;\n * }\n *\n * class CreateUserDto {\n *   // This class will inherit the validation metadata for the name property\n * }\n *\n * inheritValidationMetadata(UserDto, CreateUserDto);\n * ```\n */\nexport function inheritValidationMetadata(\n  parentClass: Type<any>,\n  targetClass: Function,\n  isPropertyInherited?: (key: string) => boolean,\n) {\n  // Check if class-validator is available in the project\n  if (!isClassValidatorAvailable()) {\n    return\n  }\n\n  try {\n    // Import class-validator dynamically\n    const classValidator: typeof import('class-validator') = require('class-validator')\n\n    // Get the metadata storage from class-validator\n    // This handles different versions of class-validator\n    const metadataStorage: import('class-validator').MetadataStorage = (classValidator as any)\n      .getMetadataStorage\n      ? (classValidator as any).getMetadataStorage()\n      : classValidator.getFromContainer(classValidator.MetadataStorage)\n\n    // Arguments for getting target validation metadata\n    const getTargetValidationMetadatasArgs = [parentClass, null!, false, false]\n\n    // Get the validation metadata from the parent class\n    const targetMetadata: ReturnType<typeof metadataStorage.getTargetValidationMetadatas> = (\n      metadataStorage.getTargetValidationMetadatas as Function\n    )(...getTargetValidationMetadatasArgs)\n\n    // Filter and map the metadata to apply to the target class\n    return (\n      targetMetadata\n        // Only include properties that should be inherited\n        .filter(({ propertyName }) => !isPropertyInherited || isPropertyInherited(propertyName))\n        .map((value) => {\n          // Get the original type metadata\n          const originalType = Reflect.getMetadata(\n            'design:type',\n            parentClass.prototype,\n            value.propertyName,\n          )\n\n          // If the original type exists, define it on the target class\n          if (originalType) {\n            Reflect.defineMetadata(\n              'design:type',\n              originalType,\n              targetClass.prototype,\n              value.propertyName,\n            )\n          }\n\n          // Add the validation metadata to the target class\n          metadataStorage.addValidationMetadata({\n            ...value,\n            target: targetClass,\n          })\n\n          // Return the property name that was processed\n          return value.propertyName\n        })\n    )\n  } catch (err: Error | any) {\n    // Log errors that occur during the inheritance process\n    logger.error(\n      `Validation (\"class-validator\") metadata cannot be inherited for \"${parentClass.name}\" class.`,\n    )\n    logger.error(err)\n  }\n}\n\n/**\n * @function isClassValidatorAvailable\n * @description Checks if the class-validator package is available in the project.\n * This is used to gracefully handle cases where class-validator is not installed.\n *\n * @returns {boolean} True if class-validator is available, false otherwise\n *\n * @internal\n */\nfunction isClassValidatorAvailable() {\n  try {\n    // Attempt to require class-validator\n    require('class-validator')\n    return true\n  } catch {\n    // Return false if class-validator is not available\n    return false\n  }\n}\n","import type { Type } from '../types'\n\n/**\n * @function inheritPropertyInitializers\n * @description Inherits property initializers from a source class to a target object.\n * This copies the default values of properties from an instance of the source class\n * to the target object, but only for properties that are undefined in the target.\n *\n * @param target - The target object to inherit property initializers to\n * @param sourceClass - The source class to inherit property initializers from\n * @param isPropertyInherited - Optional function to determine if a property should be inherited\n *                             (defaults to inheriting all properties)\n *\n * @example\n * ```typescript\n * class UserDto {\n *   name: string = 'Default Name';\n *   isActive: boolean = true;\n * }\n *\n * const target = {};\n * inheritPropertyInitializers(target, UserDto);\n * // target is now { name: 'Default Name', isActive: true }\n * ```\n */\nexport function inheritPropertyInitializers(\n  target: Record<string, any>,\n  sourceClass: Type<any>,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  isPropertyInherited = (key: string) => true,\n) {\n  try {\n    // Create a temporary instance of the source class to get its property values\n    const tempInstance = new sourceClass()\n\n    // Get all property names from the temporary instance\n    const propertyNames = Object.getOwnPropertyNames(tempInstance)\n\n    // Filter and copy properties\n    propertyNames\n      // Only include properties that are defined in the source and undefined in the target\n      .filter(\n        (propertyName) =>\n          typeof tempInstance[propertyName] !== 'undefined' &&\n          typeof target[propertyName] === 'undefined',\n      )\n      // Only include properties that should be inherited according to the predicate\n      .filter((propertyName) => isPropertyInherited(propertyName))\n      // Copy each property from the source to the target\n      .forEach((propertyName) => {\n        target[propertyName] = tempInstance[propertyName]\n      })\n  } catch {\n    // Ignore errors that might occur during instantiation or property copying\n    // This allows the function to fail gracefully if the source class can't be instantiated\n  }\n}\n","import { logger } from './logger.utils'\nimport type { Type, TransformMetadataKey } from '../types'\n\n/**\n * @function inheritTransformationMetadata\n * @description Inherits transformation metadata from a parent class to a target class.\n * This allows the target class to have the same transformation rules as the parent class.\n * If class-transformer is not available, this function does nothing.\n *\n * @param parentClass - The class to inherit transformation metadata from\n * @param targetClass - The class to apply the inherited transformation metadata to\n * @param isPropertyInherited - Optional function to determine if a property should be inherited\n * @param stackDecorators - Whether to stack decorators or replace them (default: true)\n *\n * @example\n * ```typescript\n * class UserDto {\n *   @Expose()\n *   name: string;\n *\n *   @Exclude()\n *   password: string;\n * }\n *\n * class CreateUserDto {\n *   // This class will inherit the transformation metadata for the name and password properties\n * }\n *\n * inheritTransformationMetadata(UserDto, CreateUserDto);\n * ```\n */\nexport function inheritTransformationMetadata(\n  parentClass: Type<any>,\n  targetClass: Function,\n  isPropertyInherited?: (key: string) => boolean,\n  stackDecorators = true,\n) {\n  // Check if class-transformer is available in the project\n  if (!isClassTransformerAvailable()) {\n    return\n  }\n\n  try {\n    // Define the metadata keys to inherit\n    const transformMetadataKeys: TransformMetadataKey[] = [\n      '_typeMetadatas',\n      '_exposeMetadatas',\n      '_excludeMetadatas',\n      '_transformMetadatas',\n    ]\n\n    // Inherit each type of metadata\n    transformMetadataKeys.forEach((key) =>\n      inheritTransformerMetadata(\n        key,\n        parentClass,\n        targetClass,\n        isPropertyInherited,\n        stackDecorators,\n      ),\n    )\n  } catch (err: Error | any) {\n    // Log errors that occur during the inheritance process\n    logger.error(\n      `Transformer (\"class-transformer\") metadata cannot be inherited for \"${parentClass.name}\" class.`,\n    )\n    logger.error(err)\n  }\n}\n\n/**\n * @function inheritTransformerMetadata\n * @description Helper function that inherits a specific type of transformation metadata\n * from a parent class to a target class.\n *\n * @param key - The metadata key to inherit\n * @param parentClass - The class to inherit metadata from\n * @param targetClass - The class to apply the inherited metadata to\n * @param isPropertyInherited - Optional function to determine if a property should be inherited\n * @param stackDecorators - Whether to stack decorators or replace them\n *\n * @internal\n */\nfunction inheritTransformerMetadata(\n  key: TransformMetadataKey,\n  parentClass: Type<any>,\n  targetClass: Function,\n  isPropertyInherited?: (key: string) => boolean,\n  stackDecorators = true,\n) {\n  let classTransformer: any\n\n  try {\n    // Try to import class-transformer from the cjs path (for newer versions)\n    /** \"class-transformer\" >= v0.3.x */\n    classTransformer = require('class-transformer/cjs/storage')\n  } catch {\n    // Fall back to the older import path\n    /** \"class-transformer\" <= v0.3.x */\n    classTransformer = require('class-transformer/storage')\n  }\n\n  // Get the metadata storage from class-transformer\n  const metadataStorage /*: typeof import('class-transformer/types/storage').defaultMetadataStorage */ =\n    classTransformer.defaultMetadataStorage\n\n  // Traverse the prototype chain to inherit metadata from all parent classes\n  while (parentClass && parentClass !== Object) {\n    // Check if the parent class has metadata for the current key\n    if (metadataStorage[key].has(parentClass)) {\n      // Get the metadata map for the current key\n      const metadataMap = metadataStorage[key] as Map<Function, Map<string, any>>\n      // Get the parent metadata\n      const parentMetadata = metadataMap.get(parentClass)\n\n      // Create target metadata entries by filtering and mapping parent metadata\n      const targetMetadataEntries: Iterable<[string, any]> = Array.from(parentMetadata!.entries())\n        // Only include properties that should be inherited\n        .filter(([key]) => !isPropertyInherited || isPropertyInherited(key))\n        // Map each entry to update the target reference\n        .map(([key, metadata]) => {\n          if (Array.isArray(metadata)) {\n            // \"_transformMetadatas\" is an array of elements\n            // Create a new array with updated target references\n            const targetMetadata = metadata.map((item) => ({\n              ...item,\n              target: targetClass,\n            }))\n            return [key, targetMetadata]\n          }\n          // For non-array metadata, just update the target reference\n          return [key, { ...metadata, target: targetClass }]\n        })\n\n      // If the target class already has metadata for this key\n      if (metadataMap.has(targetClass)) {\n        // Get the existing rules\n        const existingRules = metadataMap.get(targetClass)!.entries()\n        // Create a new map to merge the existing and new metadata\n        const mergeMap = new Map<string, any[]>()\n\n        // Merge the existing and new metadata\n        ;[existingRules, targetMetadataEntries].forEach((entries) => {\n          for (const [valueKey, value] of entries) {\n            if (mergeMap.has(valueKey) && stackDecorators) {\n              // If the key already exists and we're stacking decorators\n              const parentValue = mergeMap.get(valueKey)\n\n              if (Array.isArray(parentValue)) {\n                // Merge parent and child arrays if the parent value is an array\n                parentValue.push(...(Array.isArray(value) ? value : [value]))\n              }\n            } else {\n              // Otherwise, just set the value\n              mergeMap.set(valueKey, value)\n            }\n          }\n        })\n\n        // Update the metadata map with the merged map\n        metadataMap.set(targetClass, mergeMap)\n      } else {\n        // If the target class doesn't have metadata for this key yet,\n        // create a new map with the target metadata entries\n        metadataMap.set(targetClass, new Map(targetMetadataEntries))\n      }\n    }\n\n    // Move up the prototype chain\n    parentClass = Object.getPrototypeOf(parentClass)\n  }\n}\n\n/**\n * @function isClassTransformerAvailable\n * @description Checks if the class-transformer package is available in the project.\n * This is used to gracefully handle cases where class-transformer is not installed.\n *\n * @returns {boolean} True if class-transformer is available, false otherwise\n *\n * @internal\n */\nfunction isClassTransformerAvailable() {\n  try {\n    // Attempt to require class-transformer\n    require('class-transformer')\n    return true\n  } catch {\n    // Return false if class-transformer is not available\n    return false\n  }\n}\n","import {\n  inheritValidationMetadata,\n  inheritPropertyInitializers,\n  inheritTransformationMetadata,\n} from '../utils'\nimport type { MappedType } from '../interfaces'\nimport type { Type, RemoveFieldsWithType } from '../types'\n\n/**\n * @type UnionToIntersection\n * @description Utility type that converts a union type to an intersection type.\n * This uses a clever trick with function parameters and return types to achieve the conversion.\n *\n * @template U The union type to convert to an intersection\n *\n * @example\n * ```typescript\n * type Union = { a: string } | { b: number };\n * // Becomes { a: string } & { b: number }\n * type Intersection = UnionToIntersection<Union>;\n * ```\n *\n * @see https://stackoverflow.com/questions/50374908/transform-union-type-to-intersection-type\n */\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void\n  ? I\n  : never\n\n/**\n * @type ClassRefsToConstructors\n * @description Utility type that converts an array of class references to an array of their instance types.\n * It uses the infer keyword to extract the instance type from each Type<T>.\n *\n * @template T The array of class references to convert\n *\n * @example\n * ```typescript\n * type ClassRefs = [Type<Foo>, Type<Bar>];\n * // Becomes [Foo, Bar]\n * type Constructors = ClassRefsToConstructors<ClassRefs>;\n * ```\n */\ntype ClassRefsToConstructors<T extends Type[]> = {\n  [U in keyof T]: T[U] extends Type<infer V> ? V : never\n}\n\n/**\n * @type Intersection\n * @description Utility type that creates an intersection type from an array of class references.\n * It first converts the array of class references to an array of their instance types,\n * then converts that array to a union type using indexed access,\n * and finally converts the union type to an intersection type.\n *\n * @template T The array of class references to create an intersection from\n *\n * @example\n * ```typescript\n * class Foo { a: string; }\n * class Bar { b: number; }\n *\n * // Becomes MappedType<Foo & Bar>\n * type FooBar = Intersection<[Type<Foo>, Type<Bar>]>;\n * ```\n */\ntype Intersection<T extends Type[]> = MappedType<\n  RemoveFieldsWithType<UnionToIntersection<ClassRefsToConstructors<T>[number]>, Function>\n>\n\n/**\n * @function IntersectionType\n * @description Creates a new type by intersecting multiple existing classes.\n * The resulting type will have all properties from all the input classes.\n * It also inherits validation and transformation metadata from all input classes.\n *\n * @param classRefs - The classes to intersect\n *\n * @returns A new class with all properties from all input classes\n *\n * @example\n * ```typescript\n * class UserDto {\n *   @IsString()\n *   name: string;\n * }\n *\n * class AddressDto {\n *   @IsString()\n *   street: string;\n * }\n *\n * // UserWithAddressDto will have both name and street properties\n * // with the same validation rules as the original classes\n * class UserWithAddressDto extends IntersectionType(UserDto, AddressDto) {}\n * ```\n *\n * @publicApi\n */\nexport function IntersectionType<T extends Type[]>(...classRefs: T) {\n  /**\n   * Abstract class that will be returned as the intersection type\n   * It inherits property initializers from all source classes\n   */\n  abstract class IntersectionClassType {\n    constructor() {\n      // Inherit property initializers from all source classes\n      classRefs.forEach((classRef) => {\n        inheritPropertyInitializers(this, classRef)\n      })\n    }\n  }\n\n  // Inherit validation and transformation metadata from all source classes\n  classRefs.forEach((classRef) => {\n    inheritValidationMetadata(classRef, IntersectionClassType)\n    inheritTransformationMetadata(classRef, IntersectionClassType, undefined, false)\n  })\n\n  // Set the name of the class to reflect that it's an intersection of the source classes\n  const intersectedNames = classRefs.reduce((prev, ref) => prev + ref.name, '')\n  Object.defineProperty(IntersectionClassType, 'name', {\n    value: `Intersection${intersectedNames}`,\n  })\n\n  // Return the class as a MappedType\n  return IntersectionClassType as Intersection<T>\n}\n"]}