{"version":3,"sources":["../../src/logger.ts","../../src/utils/logger.utils.ts","../../src/utils/inherit-transformation-metadata.utils.ts"],"names":["key"],"mappings":"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","file":"inherit-transformation-metadata.utils.mjs","sourcesContent":["/**\n * @class Logger\n * @description A simple logger class for logging messages with different log levels.\n * This class provides methods for logging messages with different severity levels\n * and includes the context (module name) in the log output.\n */\nexport class Logger {\n  /**\n   * Creates a new Logger instance with the specified context.\n   * @param context The context (usually module name) to include in log messages\n   */\n  constructor(private readonly context: string) {}\n\n  /**\n   * Logs an error message.\n   * @param message The message to log\n   * @param trace Optional stack trace or error object\n   */\n  error(message: any, trace?: string | Error): void {\n    const timestamp = new Date().toISOString()\n    const formattedMessage = `[${timestamp}] [ERROR] [${this.context}] ${message}`\n\n    console.error(formattedMessage)\n\n    if (trace) {\n      if (trace instanceof Error) {\n        console.error(trace.stack)\n      } else {\n        console.error(trace)\n      }\n    }\n  }\n\n  /**\n   * Logs a warning message.\n   * @param message The message to log\n   */\n  warn(message: any): void {\n    const timestamp = new Date().toISOString()\n    console.warn(`[${timestamp}] [WARN] [${this.context}] ${message}`)\n  }\n\n  /**\n   * Logs an informational message.\n   * @param message The message to log\n   */\n  info(message: any): void {\n    const timestamp = new Date().toISOString()\n    console.info(`[${timestamp}] [INFO] [${this.context}] ${message}`)\n  }\n\n  /**\n   * Logs a debug message.\n   * @param message The message to log\n   */\n  debug(message: any): void {\n    const timestamp = new Date().toISOString()\n    console.debug(`[${timestamp}] [DEBUG] [${this.context}] ${message}`)\n  }\n\n  /**\n   * Logs a verbose message.\n   * @param message The message to log\n   */\n  verbose(message: any): void {\n    const timestamp = new Date().toISOString()\n    console.log(`[${timestamp}] [VERBOSE] [${this.context}] ${message}`)\n  }\n}\n","import { Logger } from '../logger'\n\n/**\n * @description Centralized logger instance for the MappedTypes module.\n * Used to log errors and other information during the execution of the module.\n * This logger provides consistent formatting and context for all log messages.\n *\n * @example\n * // Log an error message\n * logger.error('An error occurred while processing metadata');\n *\n * // Log an error with a stack trace\n * try {\n *   // Some code that might throw\n * } catch (err) {\n *   logger.error('Failed to process metadata', err);\n * }\n */\nexport const logger = new Logger('MappedTypes')\n","import { logger } from './logger.utils'\nimport type { Type, TransformMetadataKey } from '../types'\n\n/**\n * @function inheritTransformationMetadata\n * @description Inherits transformation metadata from a parent class to a target class.\n * This allows the target class to have the same transformation rules as the parent class.\n * If class-transformer is not available, this function does nothing.\n *\n * @param parentClass - The class to inherit transformation metadata from\n * @param targetClass - The class to apply the inherited transformation metadata to\n * @param isPropertyInherited - Optional function to determine if a property should be inherited\n * @param stackDecorators - Whether to stack decorators or replace them (default: true)\n *\n * @example\n * class UserDto {\n *   @Expose()\n *   name: string;\n *\n *   @Exclude()\n *   password: string;\n * }\n *\n * class CreateUserDto {\n *   // This class will inherit the transformation metadata for the name and password properties\n * }\n *\n * inheritTransformationMetadata(UserDto, CreateUserDto);\n */\nexport function inheritTransformationMetadata(\n  parentClass: Type<any>,\n  targetClass: Function,\n  isPropertyInherited?: (key: string) => boolean,\n  stackDecorators = true,\n) {\n  // Check if class-transformer is available in the project\n  if (!isClassTransformerAvailable()) {\n    return\n  }\n\n  try {\n    // Define the metadata keys to inherit\n    const transformMetadataKeys: TransformMetadataKey[] = [\n      '_typeMetadatas',\n      '_exposeMetadatas',\n      '_excludeMetadatas',\n      '_transformMetadatas',\n    ]\n\n    // Inherit each type of metadata\n    transformMetadataKeys.forEach((key) =>\n      inheritTransformerMetadata(\n        key,\n        parentClass,\n        targetClass,\n        isPropertyInherited,\n        stackDecorators,\n      ),\n    )\n  } catch (err: Error | any) {\n    // Log errors that occur during the inheritance process\n    logger.error(\n      `Transformer (\"class-transformer\") metadata cannot be inherited for \"${parentClass.name}\" class.`,\n    )\n    logger.error(err)\n  }\n}\n\n/**\n * @function inheritTransformerMetadata\n * @description Helper function that inherits a specific type of transformation metadata\n * from a parent class to a target class.\n *\n * @param key - The metadata key to inherit\n * @param parentClass - The class to inherit metadata from\n * @param targetClass - The class to apply the inherited metadata to\n * @param isPropertyInherited - Optional function to determine if a property should be inherited\n * @param stackDecorators - Whether to stack decorators or replace them\n *\n * @internal\n */\nfunction inheritTransformerMetadata(\n  key: TransformMetadataKey,\n  parentClass: Type<any>,\n  targetClass: Function,\n  isPropertyInherited?: (key: string) => boolean,\n  stackDecorators = true,\n) {\n  let classTransformer: any\n\n  try {\n    // Try to import class-transformer from the cjs path (for newer versions)\n    /** \"class-transformer\" >= v0.3.x */\n    classTransformer = require('class-transformer/cjs/storage')\n  } catch {\n    // Fall back to the older import path\n    /** \"class-transformer\" <= v0.3.x */\n    classTransformer = require('class-transformer/storage')\n  }\n\n  // Get the metadata storage from class-transformer\n  const metadataStorage /*: typeof import('class-transformer/types/storage').defaultMetadataStorage */ =\n    classTransformer.defaultMetadataStorage\n\n  // Traverse the prototype chain to inherit metadata from all parent classes\n  while (parentClass && parentClass !== Object) {\n    // Check if the parent class has metadata for the current key\n    if (metadataStorage[key].has(parentClass)) {\n      // Get the metadata map for the current key\n      const metadataMap = metadataStorage[key] as Map<Function, Map<string, any>>\n      // Get the parent metadata\n      const parentMetadata = metadataMap.get(parentClass)\n\n      // Create target metadata entries by filtering and mapping parent metadata\n      const targetMetadataEntries: Iterable<[string, any]> = Array.from(parentMetadata!.entries())\n        // Only include properties that should be inherited\n        .filter(([key]) => !isPropertyInherited || isPropertyInherited(key))\n        // Map each entry to update the target reference\n        .map(([key, metadata]) => {\n          if (Array.isArray(metadata)) {\n            // \"_transformMetadatas\" is an array of elements\n            // Create a new array with updated target references\n            const targetMetadata = metadata.map((item) => ({\n              ...item,\n              target: targetClass,\n            }))\n            return [key, targetMetadata]\n          }\n          // For non-array metadata, just update the target reference\n          return [key, { ...metadata, target: targetClass }]\n        })\n\n      // If the target class already has metadata for this key\n      if (metadataMap.has(targetClass)) {\n        // Get the existing rules\n        const existingRules = metadataMap.get(targetClass)!.entries()\n        // Create a new map to merge the existing and new metadata\n        const mergeMap = new Map<string, any[]>()\n\n        // Merge the existing and new metadata\n        ;[existingRules, targetMetadataEntries].forEach((entries) => {\n          for (const [valueKey, value] of entries) {\n            if (mergeMap.has(valueKey) && stackDecorators) {\n              // If the key already exists and we're stacking decorators\n              const parentValue = mergeMap.get(valueKey)\n\n              if (Array.isArray(parentValue)) {\n                // Merge parent and child arrays if the parent value is an array\n                parentValue.push(...(Array.isArray(value) ? value : [value]))\n              }\n            } else {\n              // Otherwise, just set the value\n              mergeMap.set(valueKey, value)\n            }\n          }\n        })\n\n        // Update the metadata map with the merged map\n        metadataMap.set(targetClass, mergeMap)\n      } else {\n        // If the target class doesn't have metadata for this key yet,\n        // create a new map with the target metadata entries\n        metadataMap.set(targetClass, new Map(targetMetadataEntries))\n      }\n    }\n\n    // Move up the prototype chain\n    parentClass = Object.getPrototypeOf(parentClass)\n  }\n}\n\n/**\n * @function isClassTransformerAvailable\n * @description Checks if the class-transformer package is available in the project.\n * This is used to gracefully handle cases where class-transformer is not installed.\n *\n * @returns {boolean} True if class-transformer is available, false otherwise\n *\n * @internal\n */\nfunction isClassTransformerAvailable() {\n  try {\n    // Attempt to require class-transformer\n    require('class-transformer')\n    return true\n  } catch {\n    // Return false if class-transformer is not available\n    return false\n  }\n}\n"]}